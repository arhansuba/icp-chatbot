"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ast_1 = require("./ast");
const file_1 = require("./file");
const package_1 = require("./package");
const resolveEntryPoint_1 = require("./utils/resolveEntryPoint");
function wrapMotoko(compiler) {
    const version = compiler.version || '(unknown)';
    const debug = require('debug')(`motoko:${version}`);
    const invoke = (key, unwrap, args) => {
        if (typeof compiler[key] !== 'function') {
            throw new Error(`Unknown compiler function: '${key}'`);
        }
        let result;
        try {
            result = compiler[key](...args);
        }
        catch (err) {
            if (err instanceof Error) {
                throw err;
            }
            throw new Error(`Unable to execute ${key}(${[...args]
                .map((x) => typeof x)
                .join(', ')}):\n${JSON.stringify(err)}`);
        }
        if (!unwrap) {
            return result;
        }
        if (!result.code) {
            throw new Error(result.diagnostics
                ? result.diagnostics
                    .map(({ message }) => message)
                    .join('; ')
                : '(no diagnostics)');
        }
        return result.code;
    };
    function parseMotokoTyped(paths) {
        if (typeof paths === 'string') {
            return mo.parseMotokoTyped([paths])[0];
        }
        return invoke('parseMotokoTyped', true, [paths]).map(({ ast, typ }) => {
            return {
                ast: (0, ast_1.simplifyAST)(ast),
                type: (0, ast_1.simplifyAST)(typ),
            };
        });
    }
    const mo = {
        version,
        compiler,
        file(path) {
            return (0, file_1.file)(mo, path);
        },
        read(path) {
            return invoke('readFile', false, [path]);
        },
        write(path, content = '') {
            if (typeof content !== 'string') {
                throw new Error('Non-string file content');
            }
            debug('+file', path);
            invoke('saveFile', false, [path, content]);
        },
        rename(path, newPath) {
            invoke('renameFile', false, [path, newPath]);
        },
        delete(path) {
            debug('-file', path);
            invoke('removeFile', false, [path]);
        },
        list(directory) {
            return invoke('readDir', false, [directory]);
        },
        fetchPackage(name, info) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!info) {
                    throw new Error('Please specify both a name and source');
                }
                return (0, package_1.fetchPackage)(name, info);
            });
        },
        installPackages(packages) {
            return __awaiter(this, void 0, void 0, function* () {
                return (0, package_1.installPackages)(mo, packages);
            });
        },
        loadPackage(pkg) {
            debug('+package', pkg.name);
            mo.validatePackage(pkg);
            const directory = `.node-motoko/${pkg.name}/${pkg.version}`;
            Object.entries(pkg.files).forEach(([path, file]) => {
                mo.write(`${directory}/${path}`, file.content);
            });
            mo.usePackage(pkg.name, directory);
        },
        usePackage(name, directory) {
            debug('@package', name, directory);
            invoke('addPackage', false, [name, directory]);
        },
        clearPackages() {
            debug('-packages');
            invoke('clearPackage', false, []);
        },
        validatePackage(pkg) {
            (0, package_1.validatePackage)(pkg);
        },
        setAliases(directory, aliases) {
            debug('aliases', directory, aliases);
            invoke('setCandidPath', false, [directory]);
            invoke('setActorAliases', false, [Object.entries(aliases)]);
        },
        setMetadata(values) {
            invoke('setPublicMetadata', false, [values]);
        },
        setRunStepLimit(limit) {
            invoke('setRunStepLimit', false, [limit]);
        },
        check(path) {
            const result = invoke('check', false, [path]);
            return result.diagnostics;
        },
        run(path, libPaths) {
            return invoke('run', false, [libPaths || [], path]);
        },
        candid(path) {
            return invoke('candid', true, [path]);
        },
        wasm(path, mode) {
            if (!mode) {
                mode = 'ic';
            }
            else if (mode !== 'ic' && mode !== 'wasi') {
                throw new Error(`Invalid WASM format: ${mode}`);
            }
            return invoke('compileWasm', true, [mode, path]);
        },
        parseCandid(content) {
            return invoke('parseCandid', true, [content]);
        },
        parseMotoko(content) {
            const ast = invoke('parseMotoko', true, [content]);
            return (0, ast_1.simplifyAST)(ast);
        },
        parseMotokoTyped,
        resolveMain(directory = '') {
            return (0, resolveEntryPoint_1.resolveMain)(mo, directory);
        },
        resolveLib(directory = '') {
            return (0, resolveEntryPoint_1.resolveLib)(mo, directory);
        },
    };
    // @ts-ignore
    mo.default = mo;
    return mo;
}
exports.default = wrapMotoko;
//# sourceMappingURL=index.js.map