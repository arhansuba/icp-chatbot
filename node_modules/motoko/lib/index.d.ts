import { Node } from './ast';
import { Package, PackageInfo } from './package';
export declare type Motoko = ReturnType<typeof wrapMotoko>;
declare type Compiler = any;
export declare type Diagnostic = {
    source: string;
    range: {
        start: {
            line: number;
            character: number;
        };
        end: {
            line: number;
            character: number;
        };
    };
    severity: number;
    code: string;
    category: string;
    message: string;
};
export declare type WasmMode = 'ic' | 'wasi';
export declare type Result = {
    value?: any;
    error: {
        message?: string;
    } | null;
};
export default function wrapMotoko(compiler: Compiler): {
    version: any;
    compiler: any;
    file(path: string): {
        path: string;
        clone(): any;
        read(): string;
        write(content: string): void;
        rename(newPath: string): void;
        delete(): void;
        list(): string[];
        check(): Diagnostic[];
        run(): {
            stdout: string;
            stderr: string;
            result: Result;
        };
        candid(): string;
        wasm(mode: WasmMode): any;
        parseCandid(): object;
        parseMotoko(): Node;
        parseMotokoTyped(): {
            ast: Node;
            type: Node;
        };
    };
    read(path: string): string;
    write(path: string, content?: string): void;
    rename(path: string, newPath: string): void;
    delete(path: string): void;
    list(directory: string): string[];
    fetchPackage(name: string, info: string | PackageInfo): Promise<Package>;
    installPackages(packages: Record<string, string | PackageInfo>): Promise<void>;
    loadPackage(pkg: Package): void;
    usePackage(name: string, directory: string): void;
    clearPackages(): void;
    validatePackage(pkg: Package): void;
    setAliases(directory: string, aliases: Record<string, string>): void;
    setMetadata(values: string): void;
    setRunStepLimit(limit: number): void;
    check(path: string): Diagnostic[];
    run(path: string, libPaths?: string[] | undefined): {
        stdout: string;
        stderr: string;
        result: Result;
    };
    candid(path: string): string;
    wasm(path: string, mode: WasmMode): any;
    parseCandid(content: string): object;
    parseMotoko(content: string): Node;
    parseMotokoTyped: {
        (paths: string): {
            ast: Node;
            type: Node;
        };
        (paths: string[]): {
            ast: Node;
            type: Node;
        }[];
    };
    resolveMain(directory?: string): string | undefined;
    resolveLib(directory?: string): string | undefined;
};
export {};
//# sourceMappingURL=index.d.ts.map