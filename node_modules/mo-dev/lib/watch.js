"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.watch = exports.findCanister = void 0;
const child_process_1 = require("child_process");
const chokidar_1 = __importDefault(require("chokidar"));
const fast_glob_1 = __importDefault(require("fast-glob"));
const fs_1 = require("fs");
const path_1 = require("path");
const picocolors_1 = __importDefault(require("picocolors"));
const cache_1 = require("./cache");
const canister_1 = require("./canister");
const dfx_1 = require("./dfx");
const testing_1 = require("./testing");
const motoko_1 = require("./utils/motoko");
const wasm_1 = __importDefault(require("./wasm"));
// Pattern to watch for file changes
const watchGlob = '**/*.mo';
// Paths to always exclude from the file watcher
const watchIgnore = ['**/node_modules/**/*', '**/.vessel/.tmp/**/*'];
// Canisters loaded from `dfx.json`
let canisters;
// Inject dev server logic into bindings created by `dfx generate`
const editJSBinding = (canister, source) => `// Modified by 'mo-dev'
${source.replace('export const createActor', 'export const _createActor')}
export function createActor(canisterId, ...args) {
    const alias = ${JSON.stringify(canister.alias)};
    const actor = _createActor(canisterId, ...args);
    if (process.env.NODE_ENV === 'development') {
      Object.keys(actor).forEach((methodName) => {
        actor[methodName] = async (...args) => {
          const response = await fetch(
            new URL(\`http://localhost:7700/call/\${alias}/\${methodName}\`),
            {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({ args }),
            },
          );
          if (!response.ok) {
            throw new Error(
              \`Received status code \${response.status} from Motoko HMR server\`,
            );
          }
          const data = await response.json();
          return data.value;
        };
      });
    }
    return actor;
}
`;
function findCanister(alias) {
    return canisters.find((c) => c.alias === alias);
}
exports.findCanister = findCanister;
function watch(settings) {
    return __awaiter(this, void 0, void 0, function* () {
        const { directory, execute, verbosity, generate, deploy, reinstall, test, hotReload, } = settings;
        const deployArgs = [];
        settings.deployArgs.forEach((arg) => {
            deployArgs.push('--argument', arg);
        });
        const log = (level, ...args) => {
            if (verbosity >= level) {
                const time = new Date().toLocaleTimeString();
                console.log(`${picocolors_1.default.dim(time)} ${picocolors_1.default.cyan(picocolors_1.default.bold('[mo-dev]'))}`, ...args);
            }
        };
        const fileCache = new cache_1.FileCache({ directory });
        const loadCanisterIds = () => {
            try {
                const network = 'local';
                const canisterIdsPath = (0, path_1.resolve)(directory, '.dfx', network, 'canister_ids.json');
                if (!(0, fs_1.existsSync)(canisterIdsPath)) {
                    return;
                }
                log(1, 'Loading canister IDs...');
                const canisterIds = JSON.parse((0, fs_1.readFileSync)(canisterIdsPath, 'utf8'));
                return Object.fromEntries(Object.entries(canisterIds)
                    .map(([alias, ids]) => [alias, ids[network]])
                    .filter(([, id]) => id));
            }
            catch (err) {
                console.error('Error while loading `canister_ids.json`:', err);
            }
        };
        const updateDfxConfig = () => __awaiter(this, void 0, void 0, function* () {
            var _a;
            try {
                const dfxConfig = yield (0, dfx_1.loadDfxConfig)(directory);
                if (!dfxConfig) {
                    console.error(`${picocolors_1.default.bold('Could not find a `dfx.json` file in directory:')} ${directory}`);
                    return;
                }
                canisters = (0, canister_1.getDfxCanisters)(directory, dfxConfig);
                if (settings.canisterNames.length) {
                    const showExpected = settings.canisterNames.some((name) => {
                        if (!canisters.some((c) => name === c.alias)) {
                            log(0, 'unexpected canister:', picocolors_1.default.yellow(picocolors_1.default.bold(name)));
                            return true;
                        }
                    });
                    if (showExpected) {
                        log(0, `options:`, picocolors_1.default.gray(canisters
                            .map((c) => picocolors_1.default.bold(picocolors_1.default.green(c.alias)))
                            .join(', ')));
                    }
                    canisters = canisters.filter((canister) => settings.canisterNames.some((name) => name === canister.alias));
                }
            }
            catch (err) {
                console.error(`Error while loading 'dfx.json' file:\n${err.message || err}`);
            }
            const runDfx = (parts, verbosity) => {
                (0, child_process_1.spawnSync)('dfx', parts, {
                    cwd: directory,
                    stdio: verbosity >= 1 ? 'inherit' : 'ignore',
                    encoding: 'utf-8',
                });
            };
            if (generate) {
                runDfx(['canister', 'create', '--all'], verbosity);
            }
            if (deploy || reinstall) {
                let canisterIds = loadCanisterIds();
                const uiAlias = '__Candid_UI';
                const uiAddress = canisterIds === null || canisterIds === void 0 ? void 0 : canisterIds[uiAlias];
                if (!uiAddress) {
                    if (generate) {
                        // Find asset canister dependencies
                        const dfxConfig = yield (0, dfx_1.loadDfxConfig)(directory);
                        const dependencies = [];
                        (_a = Object.values(dfxConfig.canisters)) === null || _a === void 0 ? void 0 : _a.forEach((config) => {
                            var _a;
                            if (config.type === 'assets') {
                                (_a = config.dependencies) === null || _a === void 0 ? void 0 : _a.forEach((dependency) => {
                                    if (!dependencies.includes(dependency)) {
                                        dependencies.push(dependency);
                                    }
                                });
                            }
                        });
                        // TODO: handle deploy args
                        dependencies.forEach((alias) => {
                            log(0, picocolors_1.default.green('prepare'), picocolors_1.default.gray(alias));
                            runDfx(['deploy', alias], 1);
                        });
                        runDfx(['generate'], 1);
                        runDfx(['deploy'], 1);
                    }
                    else {
                        // Deploy initial canisters
                        canisters.forEach((canister) => {
                            log(0, picocolors_1.default.green('prepare'), picocolors_1.default.gray(canister.alias));
                            runDfx([
                                'deploy',
                                canister.alias,
                                ...(reinstall ? ['-y'] : []),
                                ...deployArgs,
                            ], 1);
                        });
                    }
                }
                else if (canisters.length) {
                    // Skip for environments where Candid UI is not available
                    if (!process.env.MO_DEV_HIDE_URLS) {
                        // Show Candid UI addresses
                        canisters.forEach((canister) => {
                            const id = canisterIds[canister.alias];
                            if (id) {
                                log(0, picocolors_1.default.cyan(`${picocolors_1.default.bold(`${canister.alias}`)} â†’ ${picocolors_1.default.white(`http://127.0.0.1:4943?canisterId=${uiAddress}&id=${id}`)}`));
                            }
                        });
                    }
                }
            }
        });
        yield updateDfxConfig();
        const runCommand = (command, { args, pipe } = {}) => {
            if (verbosity >= 1) {
                log(1, picocolors_1.default.magenta(`${picocolors_1.default.bold('run')} ${args
                    ? `${command} [${args
                        .map((arg) => `'${arg}'`)
                        .join(', ')}]`
                    : command}`));
            }
            const commandProcess = (0, child_process_1.spawn)(command, args, {
                shell: !args,
                cwd: directory,
            });
            if (pipe) {
                process.stdin.pipe(commandProcess.stdin);
                commandProcess.stdout.pipe(process.stdout);
                commandProcess.stderr.pipe(process.stderr);
            }
            else {
                commandProcess.on('exit', (code) => {
                    if (code) {
                        commandProcess.stdout.pipe(process.stdout);
                        commandProcess.stderr.pipe(process.stderr);
                    }
                });
            }
            return commandProcess;
        };
        const finishProcess = (process) => __awaiter(this, void 0, void 0, function* () {
            if (typeof process.exitCode === 'number') {
                return process.exitCode;
            }
            return new Promise((resolve) => process.on('close', () => resolve(process.exitCode)));
        });
        let changeTimeout;
        let execProcess;
        let deployPromise;
        const deployProcesses = [];
        const notifyChange = () => {
            clearTimeout(changeTimeout);
            changeTimeout = setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                try {
                    if (execute) {
                        if (execProcess) {
                            // kill(execProcess.pid);
                            yield finishProcess(execProcess);
                        }
                        execProcess = runCommand(execute, { pipe: true });
                        // commandProcess.on('close', (code) => {
                        //     if (verbosity >= 1) {
                        //         console.log(
                        //             pc.dim('Command exited with code'),
                        //             code ? pc.yellow(code) : pc.gray(0),
                        //         );
                        //     }
                        // });
                    }
                    // Restart deployment
                    // deployProcesses.forEach((p) => kill(p.pid));
                    for (const process of deployProcesses) {
                        yield finishProcess(process);
                    }
                    yield deployPromise;
                    deployProcesses.length = 0;
                    deployPromise = (() => __awaiter(this, void 0, void 0, function* () {
                        const pipe = verbosity >= 1;
                        let testsPassed = true;
                        if (test) {
                            try {
                                const runs = yield (0, testing_1.runTests)(settings);
                                testsPassed = runs.every((run) => run.status === 'passed' ||
                                    run.status === 'skipped');
                            }
                            catch (err) {
                                testsPassed = false;
                                console.error('Error while running unit tests:', err.stack || err);
                            }
                        }
                        if (!testsPassed) {
                            if (settings.ci) {
                                process.exit(1);
                            }
                            return;
                        }
                        if (generate) {
                            const generateProcess = runCommand('dfx', {
                                // args: ['generate', canister.alias],
                                args: ['generate'],
                                pipe,
                            });
                            const exitCode = yield finishProcess(generateProcess);
                            if (exitCode === 0) {
                                log(0, picocolors_1.default.green(
                                // `generate ${pc.gray(canister.alias)}`,
                                'generate'));
                                // if (hotReload) {
                                //     const outputPath = resolve(
                                //         directory,
                                //         canister.config.declarations?.output ||
                                //             `src/declarations/${canister.alias}`,
                                //     );
                                //     const jsPath = resolve(
                                //         outputPath,
                                //         'index.js',
                                //     );
                                //     if (existsSync(jsPath)) {
                                //         try {
                                //             const binding = readFileSync(
                                //                 jsPath,
                                //                 'utf8',
                                //             );
                                //             const newBinding = editJSBinding(
                                //                 canister,
                                //                 binding,
                                //             );
                                //             writeFileSync(
                                //                 jsPath,
                                //                 newBinding,
                                //                 'utf8',
                                //             );
                                //         } catch (err) {
                                //             console.error(
                                //                 'Error while generating hot reload bindings:',
                                //                 err,
                                //             );
                                //         }
                                //     } else {
                                //         console.error(
                                //             'Error while generating hot reload bindings. File expected at path:',
                                //             jsPath,
                                //         );
                                //     }
                                // }
                            }
                            else if (settings.ci) {
                                process.exit(1);
                            }
                        }
                        for (const canister of canisters) {
                            if (deploy) {
                                const deployProcess = runCommand('dfx', {
                                    args: [
                                        'deploy',
                                        canister.alias,
                                        ...(verbosity >= 1 ? [] : ['-qq']),
                                        ...(reinstall ? ['-y'] : []),
                                        ...deployArgs,
                                    ],
                                    // TODO: hide 'Module hash ... is already installed' warnings
                                    pipe: pipe || !reinstall,
                                });
                                deployProcesses.push(deployProcess);
                                const exitCode = yield finishProcess(deployProcess);
                                if (exitCode === 0) {
                                    log(0, picocolors_1.default.green(`deploy ${picocolors_1.default.gray(canister.alias)}`));
                                }
                                else if (settings.ci) {
                                    process.exit(1);
                                }
                            }
                        }
                    }))();
                }
                catch (err) {
                    throw err;
                    // console.error(err);
                }
            }), 100);
        };
        // Update a canister on the HMR server
        const updateCanister = (canister, { quiet = false } = {}) => {
            try {
                if (hotReload) {
                    const source = fileCache.get(canister.file);
                    if (!source) {
                        console.warn('Missing source file for HMR server:', canister.file);
                        return;
                    }
                    wasm_1.default.update_canister(canister.file, canister.alias, source);
                    const file = (0, motoko_1.getVirtualFile)(canister.file);
                    file.write(source);
                    if (!quiet) {
                        log(0, picocolors_1.default.green(`update ${picocolors_1.default.gray(canister.alias)}`));
                    }
                }
                return true;
            }
            catch (err) {
                console.error(picocolors_1.default.bold(picocolors_1.default.red(`Error while updating canister '${canister.alias}':\n${err.message || err}`)));
                return false;
            }
        };
        // Remove a canister on the HMR server
        const removeCanister = (canister, { quiet = false } = {}) => {
            try {
                if (hotReload) {
                    wasm_1.default.remove_canister(canister.alias);
                    const file = (0, motoko_1.getVirtualFile)(canister.file);
                    file.delete();
                    if (!quiet) {
                        log(0, picocolors_1.default.green(`remove ${picocolors_1.default.gray(canister.alias)}`));
                    }
                }
            }
            catch (err) {
                console.error(picocolors_1.default.bold(picocolors_1.default.red(`Error while removing canister '${canister.alias}':\n${err.message || err}`)));
            }
        };
        // Synchronously prepare files
        fast_glob_1.default.sync(watchGlob, { cwd: directory, ignore: watchIgnore }).forEach((path) => {
            const resolvedPath = (0, path_1.resolve)(directory, path);
            canisters === null || canisters === void 0 ? void 0 : canisters.forEach((canister) => {
                if (resolvedPath === canister.file) {
                    fileCache.update(resolvedPath);
                    updateCanister(canister, { quiet: true });
                }
            });
        });
        if (settings.ci) {
            notifyChange();
        }
        else {
            if (verbosity >= 1) {
                console.log(picocolors_1.default.gray('Waiting for Motoko file changes...'));
            }
            const dfxWatcher = chokidar_1.default
                .watch('./dfx.json', { cwd: directory, ignored: watchIgnore })
                .on('change', (path) => __awaiter(this, void 0, void 0, function* () {
                if (!path.endsWith('dfx.json')) {
                    console.warn('Received unexpected `dfx.json` path:', path);
                    return;
                }
                notifyChange();
                console.log(picocolors_1.default.blue(`${picocolors_1.default.bold('change')} ${path}`));
                const previousCanisters = canisters;
                yield updateDfxConfig();
                previousCanisters === null || previousCanisters === void 0 ? void 0 : previousCanisters.forEach((canister) => {
                    if (!(canisters === null || canisters === void 0 ? void 0 : canisters.some((c) => c.alias === canister.alias))) {
                        removeCanister(canister);
                    }
                });
                canisters === null || canisters === void 0 ? void 0 : canisters.forEach((canister) => updateCanister(canister));
            }));
            const moWatcher = chokidar_1.default
                .watch(watchGlob, { cwd: directory, ignored: watchIgnore })
                .on('all', (event, path) => {
                if (!path.endsWith('.mo')) {
                    return;
                }
                log(1, picocolors_1.default.blue(`${picocolors_1.default.bold(event)} ${path}`));
                let shouldNotify = true;
                const resolvedPath = (0, path_1.resolve)(directory, path);
                if (event === 'unlink') {
                    fileCache.invalidate(resolvedPath);
                }
                else {
                    if (!fileCache.update(resolvedPath)) {
                        shouldNotify = false;
                    }
                    log(2, 'cache', resolvedPath);
                }
                canisters === null || canisters === void 0 ? void 0 : canisters.forEach((canister) => {
                    if (resolvedPath === canister.file) {
                        if (event === 'unlink') {
                            removeCanister(canister);
                        }
                        else if (!updateCanister(canister)) {
                            shouldNotify = false;
                        }
                    }
                });
                if (shouldNotify) {
                    notifyChange();
                }
            });
            return {
                dfxJson: dfxWatcher,
                motoko: moWatcher,
                close() {
                    dfxWatcher.close();
                    moWatcher.close();
                },
            };
        }
    });
}
exports.watch = watch;
//# sourceMappingURL=watch.js.map