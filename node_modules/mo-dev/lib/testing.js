"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runTests = exports.asTestMode = void 0;
const execa_1 = __importDefault(require("execa"));
const fast_glob_1 = __importDefault(require("fast-glob"));
const fs_1 = require("fs");
const promises_1 = require("fs/promises");
const node_cleanup_1 = __importDefault(require("node-cleanup"));
const path_1 = require("path");
const picocolors_1 = __importDefault(require("picocolors"));
const shell_escape_1 = __importDefault(require("shell-escape"));
const dfx_1 = require("./dfx");
const settings_1 = require("./settings");
function asTestMode(mode) {
    // TODO: possibly validate here
    return mode;
}
exports.asTestMode = asTestMode;
function runTests(options, callback) {
    var _a, _b, _c;
    return __awaiter(this, void 0, void 0, function* () {
        const settings = (yield (0, settings_1.validateSettings)(options));
        const { directory } = settings;
        const testFilePattern = '*.test.mo';
        const paths = (yield (0, fast_glob_1.default)(`**/${testFilePattern}`, {
            cwd: directory,
            dot: false,
            ignore: ['**/node_modules/**'],
        })).filter((path) => {
            const filename = (0, path_1.basename)(path);
            return (!settings.testFiles.length ||
                settings.testFiles.some((f) => filename.startsWith(f)));
        });
        const mocPath = yield findMocPath(settings);
        const dfxSources = yield (0, dfx_1.loadDfxSources)(directory);
        if (settings.verbosity >= 1) {
            console.log(picocolors_1.default.magenta(dfxSources !== null && dfxSources !== void 0 ? dfxSources : '(no package sources)'));
        }
        if (settings.verbosity >= 0) {
            console.log(`Running ${paths.length} unit test file${paths.length === 1 ? '' : 's'} ${picocolors_1.default.dim(`(${settings.testFiles.length
                ? settings.testFiles.map((f) => `${f}*`).join(', ')
                : testFilePattern})`)}\n`);
        }
        const defaultStatusEmoji = '❓';
        const statusEmojis = {
            passed: '✅',
            failed: '❌',
            skipped: '⏩',
            errored: '❗',
        };
        const runs = [];
        for (const path of paths) {
            const test = {
                path: (0, path_1.join)(directory, path),
            };
            const fileRuns = yield runTestFile(test, settings, {
                mocPath,
                dfxSources,
            });
            for (const run of fileRuns) {
                runs.push(run);
                if (callback) {
                    yield callback(run);
                }
                if (settings.verbosity >= 0) {
                    const important = run.status === 'errored' || run.status === 'failed';
                    if (important) {
                        if ((_a = run.stdout) === null || _a === void 0 ? void 0 : _a.trim()) {
                            console.error(run.stdout);
                        }
                        if ((_b = run.stderr) === null || _b === void 0 ? void 0 : _b.trim()) {
                            console.error(picocolors_1.default.bold(picocolors_1.default.red(run.stderr)));
                        }
                    }
                    const showTestMode = settings.testModes.length > 1 ||
                        !settings.testModes.includes(run.mode);
                    const decorateExtension = '.test.mo';
                    const decoratedPath = run.test.path.endsWith(decorateExtension)
                        ? `${run.test.path.slice(0, -decorateExtension.length)}`
                        : run.test.path;
                    console.log(picocolors_1.default.white(`${(_c = statusEmojis[run.status]) !== null && _c !== void 0 ? _c : defaultStatusEmoji} ${(0, path_1.relative)(settings.directory, decoratedPath)}${showTestMode ? picocolors_1.default.dim(` (${run.mode})`) : ''}`));
                }
            }
        }
        if (runs.length && settings.verbosity >= 0) {
            const counts = {};
            runs.forEach((run) => (counts[run.status] = (counts[run.status] || 0) + 1));
            console.log();
            console.log(['passed', 'failed', 'errored', 'skipped']
                .filter((s) => s in counts)
                .map((s) => `${counts[s]} ${s}`)
                .concat([`${runs.length} total`])
                .join(', '));
            console.log();
        }
        return runs;
    });
}
exports.runTests = runTests;
function runTestFile(test, settings, shared) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const source = yield (0, promises_1.readFile)(test.path, 'utf8');
        const modes = [];
        const modeRegex = /\/\/[^\S\n]*@testmode[^\S\n]*([a-zA-Z]+)/g;
        let nextMode;
        while ((nextMode = (_a = modeRegex.exec(source)) === null || _a === void 0 ? void 0 : _a[1])) {
            modes.push(asTestMode(nextMode));
        }
        if (!modes.length) {
            modes.push(...settings.testModes);
        }
        const runs = [];
        for (const mode of modes) {
            runs.push(yield runTest(test, mode, settings, shared));
        }
        return runs;
    });
}
function runTest(test, mode, settings, { mocPath, dfxSources }) {
    return __awaiter(this, void 0, void 0, function* () {
        const { path } = test;
        if (settings.verbosity >= 1) {
            console.log(picocolors_1.default.blue(`Running test: ${(0, path_1.relative)(settings.directory, test.path)} (${mode})`));
        }
        try {
            if (mode === 'interpreter') {
                const interpretResult = yield (0, execa_1.default)(`${(0, shell_escape_1.default)([mocPath, '-r', path])}${dfxSources ? ` ${dfxSources}` : ''}`, { shell: true, cwd: settings.directory, reject: false });
                return {
                    test,
                    mode,
                    status: interpretResult.failed ? 'failed' : 'passed',
                    stdout: interpretResult.stdout,
                    stderr: interpretResult.stderr,
                };
            }
            else if (mode === 'wasi') {
                const wasmPath = `${path.replace(/\.mo$/i, '')}.wasm`;
                const cleanup = () => {
                    if ((0, fs_1.existsSync)(wasmPath)) {
                        (0, fs_1.unlinkSync)(wasmPath);
                    }
                };
                cleanupHandlers.add(cleanup);
                try {
                    yield (0, execa_1.default)(`${(0, shell_escape_1.default)([
                        mocPath,
                        '-wasi-system-api',
                        '-o',
                        wasmPath,
                        path,
                    ])}${dfxSources ? ` ${dfxSources}` : ''}`, { shell: true, cwd: settings.directory });
                    const wasmtimeResult = yield (0, execa_1.default)('wasmtime', [(0, path_1.basename)(wasmPath)], {
                        cwd: (0, path_1.dirname)(path),
                        reject: false,
                    });
                    return {
                        test,
                        mode,
                        status: wasmtimeResult.failed ? 'failed' : 'passed',
                        stdout: wasmtimeResult.stdout,
                        stderr: wasmtimeResult.stderr,
                    };
                }
                finally {
                    cleanup();
                    cleanupHandlers.delete(cleanup);
                }
            }
            else {
                throw new Error(`Invalid test mode: '${mode}'`);
            }
        }
        catch (err) {
            return {
                test,
                mode,
                status: 'errored',
                stdout: err.stdout,
                stderr: err.stderr || String(err.stack || err),
            };
        }
    });
}
const dfxCacheLocationMap = new Map();
function findDfxCacheLocation(directory) {
    return __awaiter(this, void 0, void 0, function* () {
        let cacheLocation = dfxCacheLocationMap.get(directory);
        if (!cacheLocation) {
            cacheLocation = (yield (0, execa_1.default)('dfx', ['cache', 'show'], {
                cwd: directory,
            })).stdout;
            dfxCacheLocationMap.set(directory, cacheLocation);
        }
        return cacheLocation;
    });
}
function findMocPath(settings) {
    return __awaiter(this, void 0, void 0, function* () {
        const mocCommand = 'moc';
        return (
        // (await which(mocCommand, { nothrow: true })) ||
        process.env.MOC_BINARY ||
            (0, path_1.join)(yield findDfxCacheLocation(settings.directory), mocCommand));
    });
}
const cleanupHandlers = new Set();
(0, node_cleanup_1.default)((...args) => {
    for (const handler of cleanupHandlers) {
        handler(...args);
    }
});
//# sourceMappingURL=testing.js.map