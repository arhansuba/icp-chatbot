"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const out_of_character_1 = __importDefault(require("out-of-character"));
const LINE_COMMENT = '//';
function preprocess(code, options) {
    code = code.replace(/\t/g, ' '.repeat(options.tabWidth)); // convert tabs to spaces
    code = code.replace(/[ \t]+(?=\r?\n)/g, ''); // remove trailing spaces
    code = out_of_character_1.default.replace(code); // remove invisible unicode characters
    if (options.semi) {
        // Infer semicolons
        let nextIndent = 0;
        const reversedLines = code.split('\n').reverse();
        code = reversedLines
            .map((line, i) => {
            const trimmedLine = line.trim();
            if (!trimmedLine) {
                return line;
            }
            // if (trimmedLine.startsWith(LINE_COMMENT)) {
            //     const comment = trimmedLine
            //         .substring(LINE_COMMENT.length)
            //         .trim();
            //     return line;
            // }
            let indent = 0;
            while (indent < line.length && line.charAt(indent) === ' ') {
                indent++;
            }
            const nextTrimmedLine = (reversedLines[i - 1] || '').trim();
            // const previousTrimmedLine = (lines[i + 1] || '').trim();
            if (trimmedLine === '}' &&
                !/^(else|catch)([^a-zA-Z0-9_]|$)/.test(nextTrimmedLine)) {
                line += ';';
            }
            nextIndent = indent;
            return line;
        })
            .reverse()
            .join('\n');
    }
    return code;
}
exports.default = preprocess;
//# sourceMappingURL=preprocess.js.map